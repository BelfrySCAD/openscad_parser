from dataclasses import dataclass
from arpeggio import PTNodeVisitor
from typing import Optional

from .source_map import SourceMap
from .nodes import *


@dataclass
class Position:
    """Represents a location in a source origin.
    
    Attributes:
        origin: Identifier for the source origin (e.g., file path, "<editor>", etc.)
        line: Line number (1-indexed)
        column: Column number (1-indexed)
    """
    origin: str
    line: int
    column: int

    def __repr__(self):
        return f"{self.origin}:{self.line}:{self.column}"


class SemanticChildren(list):
    """List-like container that supports children.<rule_name> access."""

    def __init__(self, items, rule_map):
        super().__init__(items)
        self._rule_map = rule_map

    def __getattr__(self, name):
        return self._rule_map.get(name, [])


class ASTBuilderVisitor(PTNodeVisitor):
    """
    Visits the parse tree generated by the PEG grammar in __init__.py and builds the AST defined in ast.py.
    """
    
    def __init__(self, parser, source_map=None, file=""):
        """Initialize the visitor with the parser and optional source map or file path.
        
        Args:
            parser: The Arpeggio parser instance (needed to access input for position conversion)
            source_map: Optional SourceMap for tracking positions across multiple origins
            file: Optional file path for source location tracking (deprecated, use source_map)
        """
        super().__init__()
        self.parser = parser
        if source_map is not None:
            self.source_map = source_map
            self.file = ""  # Not used when source_map is provided
        else:
            # Backward compatibility: create a simple source map from file
            self.source_map = SourceMap()
            if file:
                # We can't get the content here, but we'll handle it in _get_node_position
                self.file = file
            else:
                self.file = ""
    
    def visit_parse_tree(self, parse_tree):
        """Visit a parse tree and return the AST.
        
        This is the main entry point for converting a parse tree to an AST.
        
        Args:
            parse_tree: The root node of an Arpeggio parse tree
            
        Returns:
            The root AST node (or list of AST nodes for the root level)
        """
        return self._visit_node(parse_tree)
    
    def _visit_node(self, node):
        """Recursively visit a parse tree node and return AST.
        
        This method handles the visitor pattern for Arpeggio parse trees.
        Terminal nodes are passed through as their values, and NonTerminal nodes
        are visited using their rule_name to find the appropriate visit method.
        NonTerminal nodes without visit methods are passed through as the node itself.
        
        Args:
            node: An Arpeggio parse tree node
            
        Returns:
            The AST node (or list of AST nodes) for this parse tree node,
            or the node/value itself if it should be passed through
        """
        if node is None:
            return None
        
        # Get the rule name for this node
        if not hasattr(node, 'rule_name'):
            # Terminal node - return its value so parent can use it directly
            return getattr(node, 'value', node)
        
        rule_name = node.rule_name
        
        # Visit children first
        # Arpeggio's NonTerminal objects are iterable, so iterate directly
        children = []
        rule_map = {}
        try:
            # Try to iterate over the node (Arpeggio NonTerminal objects are iterable)
            for child in node:
                child_ast = self._visit_node(child)
                if child_ast is not None:
                    child_rule_name = getattr(child, "rule_name", None)
                    if child_rule_name:
                        rule_map.setdefault(child_rule_name, []).append(child_ast)
                    # If child_ast is a list, extend; otherwise append
                    if isinstance(child_ast, list):
                        children.extend(child_ast)
                    else:
                        children.append(child_ast)
        except (TypeError, AttributeError):
            # Node is not iterable, skip children
            pass
        
        children = SemanticChildren(children, rule_map)
        # Call the appropriate visit method
        visit_method_name = f"visit_{rule_name}"
        visit_method = getattr(self, visit_method_name, None)
        if visit_method:
            try:
                result = visit_method(node, children)
                print(f"\n#####################\n{visit_method_name=}\n{node=}\n{children=}\n{result=}\n")
                return result
            except Exception as e:
                # If visit method fails, return children or None
                return children if children else None
        else:
            # No visit method - pass through the node itself so parent can access rule_name/value
            # This is useful for operator nodes like TOK_BINARY_OR, TOK_EQUAL, etc.
            return node
    
    def _get_node_position(self, node):
        """Extract position information from an Arpeggio parse tree node.
        
        Uses SourceMap to map positions back to original origins if available.
        
        Args:
            node: Arpeggio parse tree node
            
        Returns:
            Position object for the node
        """
        if hasattr(node, 'position'):
            char_pos = node.position
        else:
            char_pos = 0
        
        # Use SourceMap if available to map position back to original origin
        if hasattr(self, 'source_map') and self.source_map.get_segments():
            location = self.source_map.get_location(char_pos)
            return Position(origin=location.origin, line=location.line, column=location.column)
        else:
            # Fallback: calculate line/column from character position
            input_str = self.parser.input if hasattr(self.parser, 'input') else ""
            if not input_str or char_pos < 0 or char_pos > len(input_str):
                line = 1
                column = 1
            else:
                text_before = input_str[:char_pos]
                line = text_before.count('\n') + 1
                last_newline = text_before.rfind('\n')
                column = char_pos - last_newline  # 1-indexed
            
            return Position(origin=self.file if self.file else "<unknown>", line=line, column=column)


    # -- Basic Tokens --

    def visit_TOK_ID(self, node, children):
        # Prefer the last child for value (to avoid list-wrapping problems)
        return Identifier(
            name=str(node.value),
            position=self._get_node_position(node)
        )

    def visit_string_contents(self, node, children):
        return str(children[-1]) if children else str(node.value)

    def visit_string_literal(self, node, children):
        # Grammar: (TOK_DQUOTE, _(r'([^"\\]|\\.|\\$)*', str_repr='string'), TOK_DQUOTE)
        # After visiting: [string_content] (TOK_DQUOTE nodes return None)
        # The string content is a Terminal node, extract its value
        value = children[-1] if children else str(node.value)
        return StringLiteral(
            val=value,
            position=self._get_node_position(node)
        )

    def visit_TOK_NUMBER(self, node, children):
        value = children[-1] if children else node.value
        return NumberLiteral(
            val=float(value),
            position=self._get_node_position(node)
        )
    
    def visit_KWD_TRUE(self, node, children):
        return BooleanLiteral(
            val=True,
            position=self._get_node_position(node)
        )

    def visit_KWD_FALSE(self, node, children):
        return BooleanLiteral(
            val=False,
            position=self._get_node_position(node)
        )

    def visit_KWD_UNDEF(self, node, children):
        return UndefinedLiteral(position=self._get_node_position(node))


    # -- Syntactical noise --

    def visit_whitespace_only(self, node, children):
        return None

    def visit_TOK_LOGICAL_OR(self, node, children):
        return None

    def visit_TOK_LOGICAL_AND(self, node, children):
        return None

    def visit_TOK_LOGICAL_NOT(self, node, children):
        return None

    def visit_TOK_BINARY_OR(self, node, children):
        return None

    def visit_TOK_BINARY_AND(self, node, children):
        return None

    def visit_TOK_BINARY_NOT(self, node, children):
        return None

    def visit_TOK_BINARY_SHIFT_LEFT(self, node, children):
        return None

    def visit_TOK_BINARY_SHIFT_RIGHT(self, node, children):
        return None

    def visit_TOK_GT(self, node, children):
        return None

    def visit_TOK_LT(self, node, children):
        return None

    def visit_TOK_GTE(self, node, children):
        return None

    def visit_TOK_LTE(self, node, children):
        return None

    def visit_TOK_EQUAL(self, node, children):
        return None

    def visit_TOK_NOTEQUAL(self, node, children):
        return None

    def visit_TOK_QUESTION(self, node, children):
        return None

    def visit_TOK_ADD(self, node, children):
        return '+'  # For later operator differentiation

    def visit_TOK_SUBTRACT(self, node, children):
        return '-'  # For later operator differentiation

    def visit_TOK_MULTIPLY(self, node, children):
        return '*'  # For later operator differentiation

    def visit_TOK_DIVIDE(self, node, children):
        return '/'  # For later operator differentiation

    def visit_TOK_MODULO(self, node, children):
        return '%'  # For later operator differentiation

    def visit_TOK_EXPONENT(self, node, children):
        return None

    def visit_MOD_SHOW_ONLY(self, node, children):
        return None

    def visit_MOD_HIGHLIGHT(self, node, children):
        return None

    def visit_MOD_BACKGROUND(self, node, children):
        return None

    def visit_MOD_DISABLE(self, node, children):
        return None

    def visit_TOK_DQUOTE(self, node, children):
        return None

    def visit_TOK_BRACE(self, node, children):
        return None

    def visit_TOK_ENDBRACE(self, node, children):
        return None

    def visit_TOK_BRACKET(self, node, children):
        return None

    def visit_TOK_ENDBRACKET(self, node, children):
        return None

    def visit_TOK_COLON(self, node, children):
        return None

    def visit_TOK_SEMICOLON(self, node, children):
        return None

    def visit_TOK_COMMA(self, node, children):
        return None

    def visit_TOK_PERIOD(self, node, children):
        return None

    def visit_TOK_PAREN(self, node, children):
        return None

    def visit_TOK_ENDPAREN(self, node, children):
        return None

    def visit_KWD_MODULE(self, node, children):
        return None

    def visit_KWD_FUNCTION(self, node, children):
        return None

    def visit_KWD_USE(self, node, children):
        return None

    def visit_KWD_INCLUDE(self, node, children):
        return None

    def visit_KWD_IF(self, node, children):
        return None

    def visit_KWD_ELSE(self, node, children):
        return None

    def visit_KWD_FOR(self, node, children):
        return None

    def visit_KWD_INTERSECTION_FOR(self, node, children):
        return None

    def visit_KWD_LET(self, node, children):
        return None

    def visit_KWD_ASSERT(self, node, children):
        return None

    def visit_KWD_ECHO(self, node, children):
        return None

    def visit_KWD_EACH(self, node, children):
        return None

    def visit_TOK_ASSIGN(self, node, children):
        return None

    def visit_TOK_SHOW_ONLY(self, node, children):
        return None

    def visit_TOK_HIGHLIGHT(self, node, children):
        return None

    def visit_TOK_BACKGROUND(self, node, children):
        return None

    def visit_TOK_DISABLE(self, node, children):
        return None


    # --- Parameters ---

    def visit_module_name(self, node, children):
        return children[0] if children else None

    def visit_function_name(self, node, children):
        return children[0] if children else None

    def visit_variable_name(self, node, children):
        return children[0] if children else None

    def visit_module_instantiation_name(self, node, children):
        return children[0] if children else None

    def visit_member_name(self, node, children):
        return children[0] if children else None

    def visit_variable_or_function_name(self, node, children):
        return children[0] if children else None

    def visit_parameter_block(self, node, children):
        # Grammar: (TOK_PAREN, parameters, TOK_ENDPAREN)
        # After visiting: [parameters_list] (TOK_PAREN and TOK_ENDPAREN return None)
        return list(children) if children else []

    def visit_parameters(self, node, children):
        # Grammar: (ZeroOrMore(parameter, sep=TOK_COMMA), ZeroOrMore(TOK_COMMA))
        # Filter out None values (commas) and return list of ParameterDeclaration
        return list(children) if children else []

    def visit_parameter(self, node, children):
        return children[0]

    def visit_parameter_with_default(self, node, children):
        return ParameterDeclaration(name=children[0], default=children[1], position=self._get_node_position(node))

    def visit_parameter_without_default(self, node, children):
        name = children[0] if children else Identifier(
            name=getattr(node, "value", ""),
            position=self._get_node_position(node)
        )
        return ParameterDeclaration(name=name, default=None, position=self._get_node_position(node))


    # --- Arguments ---
    
    def visit_argument_block(self, node, children):
        # Grammar: (TOK_PAREN, arguments, TOK_ENDPAREN)
        # After visiting: [arguments_list] (TOK_PAREN and TOK_ENDPAREN return None)
        return list(children) if children else []

    def visit_arguments(self, node, children):
        # Grammar: (ZeroOrMore(argument, sep=TOK_COMMA), Optional(TOK_COMMA))
        # Filter out None values (commas) and return list of Argument
        if hasattr(children, "argument") and children.argument:
            return list(children.argument)
        return [child for child in children if child is not None and isinstance(child, Argument)]  # pragma: no cover

    def visit_argument(self, node, children):
        return children[0]

    def visit_positional_argument(self, node, children):
        return PositionalArgument(expr=children[0], position=self._get_node_position(node))

    def visit_named_argument(self, node, children):
        return NamedArgument(name=children[0], expr=children[1], position=self._get_node_position(node))

    # --- Module/Function Declarations ---

    def visit_module_definition(self, node, children):
        # Grammar: (KWD_MODULE, module_name, parameter_block, statement)
        # After visiting: [Identifier, parameters, statement] (KWD_MODULE returns None)
        if hasattr(children, "module_name"):
            name = children.module_name[0] if children.module_name else None
            parameters = children.parameter_block[0] if hasattr(children, "parameter_block") and children.parameter_block else []
            statement = list(children.statement) if hasattr(children, "statement") and children.statement else []
        else:
            name = children[0] if children else None
            parameters = children[1] if len(children) > 1 else []
            statement = children[2] if len(children) > 2 else []
        if name is None:
            raise ValueError("module_definition should have a name")
        if parameters is None:
            parameters = []  # pragma: no cover
        if not isinstance(parameters, list):
            parameters = [parameters]  # pragma: no cover
        if statement is None:
            statement = []  # pragma: no cover
        if not isinstance(statement, list):
            statement = [statement]
        # Flatten nested statement lists and keep only ModuleInstantiation nodes
        flattened = []
        stack = list(statement)
        while stack:
            item = stack.pop(0)
            if isinstance(item, list):
                stack = item + stack
                continue
            if isinstance(item, ModuleInstantiation):
                flattened.append(item)
        return ModuleDeclaration(name=name, parameters=parameters, children=flattened, position=self._get_node_position(node))

    def visit_function_definition(self, node, children):
        # Grammar: (KWD_FUNCTION, function_name, parameter_block, TOK_ASSIGN, expr, TOK_SEMICOLON)
        # After visiting: [Identifier, parameters, expr] (KWD_FUNCTION, TOK_ASSIGN, TOK_SEMICOLON return None)
        if hasattr(children, "function_name"):
            name = children.function_name[0] if children.function_name else None
            parameters = children.parameter_block[0] if hasattr(children, "parameter_block") and children.parameter_block else []
            expr = children.expr[0] if hasattr(children, "expr") and children.expr else None
        else:
            name = children[0] if children else None
            parameters = children[1] if len(children) > 1 else []
            expr = children[2] if len(children) > 2 else None
        if name is None:
            raise ValueError("FunctionDeclarationNode should have an Identifier")
        if expr is None:
            raise ValueError("FunctionDeclarationNode should have an Expression")
        if parameters is None:
            parameters = []  # pragma: no cover
        if not isinstance(parameters, list):
            parameters = [parameters]  # pragma: no cover
        return FunctionDeclaration(name=name, parameters=parameters, expr=expr, position=self._get_node_position(node))
    
    def visit_use_include_file(self, node, children):
        if not children:
            return ""  # pragma: no cover
        # Pick the first non-angle-bracket token as the filepath content
        for child in children:
            value = child.value if hasattr(child, "value") else str(child)
            if value not in ["<", ">"]:
                return str(value)
        return ""  # pragma: no cover

    def visit_use_statement(self, node, children):
        filepath = children.use_include_file[0] if hasattr(children, "use_include_file") and children.use_include_file else (children[0] if children else "")
        if not filepath:
            raise ValueError("UseStatementNode should have a filepath")
        if isinstance(filepath, str):
            filepath = StringLiteral(val=filepath, position=self._get_node_position(node))
        return UseStatement(filepath=filepath, position=self._get_node_position(node))
    
    def visit_include_statement(self, node, children):
        filepath = children.use_include_file[0] if hasattr(children, "use_include_file") and children.use_include_file else (children[0] if children else "")
        if not filepath:
            raise ValueError("IncludeStatementNode should have a filepath")
        if isinstance(filepath, str):
            filepath = StringLiteral(val=filepath, position=self._get_node_position(node))
        return IncludeStatement(filepath=filepath, position=self._get_node_position(node))

    def visit_assignments_expr(self, node, children):
        # Grammar: (ZeroOrMore(assignment_expr, sep=TOK_COMMA), Optional(TOK_COMMA))
        # Filter out None values (commas) and return list of Assignment
        if hasattr(children, "assignment_expr") and children.assignment_expr:
            return list(children.assignment_expr)
        return [child for child in children if child is not None and isinstance(child, Assignment)]  # pragma: no cover
    
    def visit_assignment_expr(self, node, children):
        # Grammar: (variable_name, TOK_ASSIGN, expr)
        # After visiting: [Identifier, expr] (TOK_ASSIGN returns None)
        if len(children) < 2:
            raise ValueError("assignment_expr should have an Expression child")
        return Assignment(name=children[0], expr=children[1], position=self._get_node_position(node))
    
    def visit_let_expr(self, node, children):
        # Grammar: (KWD_LET, TOK_PAREN, assignments_expr, TOK_ENDPAREN, expr)
        # After visiting: [assignments_list, expr] (KWD_LET, TOK_PAREN, TOK_ENDPAREN return None)
        if hasattr(children, "assignments_expr"):
            assignments = children.assignments_expr[0] if children.assignments_expr else []
            body = children.expr[0] if hasattr(children, "expr") and children.expr else None
        else:
            assignments = children[0] if len(children) > 0 else []
            body = children[1] if len(children) > 1 else None
        if body is None:
            raise ValueError("let_expr should have an Expression body")
        return LetOp(assignments=assignments, body=body, position=self._get_node_position(node))
    
    def visit_assert_expr(self, node, children):
        # Grammar: (KWD_ASSERT, TOK_PAREN, arguments, TOK_ENDPAREN, Optional(expr))
        # After visiting: [arguments_list, expr or None] (KWD_ASSERT, TOK_PAREN, TOK_ENDPAREN return None)
        if hasattr(children, "arguments"):
            arguments = children.arguments[0] if children.arguments else []
            body = children.expr[0] if hasattr(children, "expr") and children.expr else None
        else:
            arguments = children[0] if len(children) > 0 else []
            body = children[1] if len(children) > 1 else None
        if body is None:
            raise ValueError("assert_expr should have an Expression body")
        return AssertOp(arguments=arguments, body=body, position=self._get_node_position(node))
    
    def visit_echo_expr(self, node, children):
        # Grammar: (KWD_ECHO, TOK_PAREN, arguments, TOK_ENDPAREN, Optional(expr))
        # After visiting: [arguments_list, expr or None] (KWD_ECHO, TOK_PAREN, TOK_ENDPAREN return None)
        if hasattr(children, "arguments"):
            arguments = children.arguments[0] if children.arguments else []
            body = children.expr[0] if hasattr(children, "expr") and children.expr else None
        else:
            arguments = children[0] if len(children) > 0 else []
            body = children[1] if len(children) > 1 else None
        if body is None:
            raise ValueError("echo_expr should have an Expression body")
        return EchoOp(arguments=arguments, body=body, position=self._get_node_position(node))
    
    def visit_ternary_expr(self, node, children):
        # Grammar: (prec_logical_or, TOK_QUESTION, expr, TOK_COLON, expr)
        # After visiting: [condition, true_expr, false_expr] (TOK_QUESTION and TOK_COLON return None)
        if hasattr(children, "prec_logical_or"):
            condition = children.prec_logical_or[0] if children.prec_logical_or else None
            exprs = children.expr if hasattr(children, "expr") else []
        else:
            condition = children[0] if len(children) > 0 else None
            exprs = children[1:] if len(children) > 1 else []
        true_expr = exprs[0] if len(exprs) > 0 else None
        false_expr = exprs[1] if len(exprs) > 1 else None
        if condition is None or true_expr is None or false_expr is None:
            raise ValueError("ternary_expr should have 3 Expression children (condition, true, false)")
        return TernaryOp(condition=condition, true_expr=true_expr, false_expr=false_expr, position=self._get_node_position(node))
    
    def visit_prec_logical_or(self, node, children):
        # prec_logical_or rule: OneOrMore(prec_logical_and, sep=TOK_LOGICAL_OR)
        # Build left-associative tree
        if len(children) == 1:
            return children[0]
        result = children[0]
        for i in range(1, len(children)):
            result = LogicalOrOp(left=result, right=children[i], position=self._get_node_position(node))
        return result
    
    def visit_prec_logical_and(self, node, children):
        # prec_logical_and rule: OneOrMore(prec_equality, sep=TOK_LOGICAL_AND)
        if len(children) == 1:
            return children[0]
        result = children[0]
        for i in range(1, len(children)):
            result = LogicalAndOp(left=result, right=children[i], position=self._get_node_position(node))
        return result
    
    def visit_prec_equality(self, node, children):
        # prec_equality rule: OneOrMore(prec_comparison, sep=[TOK_EQUAL, TOK_NOTEQUAL])
        # The node structure is: [prec_comparison, operator, prec_comparison, operator, ...]
        # But Terminal nodes (operators) return None from _visit_node, so we need to access raw children
        if len(children) == 1:
            return children[0]
        
        # Get raw node children to access operators
        try:
            node_children = list(node)
            # node_children alternates: operand, operator, operand, operator, ...
            # children list has only the operands (Terminal nodes filtered out)
            result = children[0]
            operand_idx = 1  # Index into children list (operands only)
            
            for i in range(1, len(node_children), 2):  # Skip every other (operators)
                if i < len(node_children):
                    operator_node = node_children[i]
                    # Check if it's TOK_EQUAL or TOK_NOTEQUAL
                    if hasattr(operator_node, 'rule_name'):
                        if operator_node.rule_name == 'TOK_EQUAL':
                            operator = '=='
                        elif operator_node.rule_name == 'TOK_NOTEQUAL':
                            operator = '!='
                        else:
                            operator = operator_node.value if hasattr(operator_node, 'value') else str(operator_node)
                    else:
                        operator = operator_node.value if hasattr(operator_node, 'value') else str(operator_node)  # pragma: no cover
                    
                    if operand_idx < len(children):
                        right_operand = children[operand_idx]
                        if operator == '==' or operator == 'TOK_EQUAL':
                            result = EqualityOp(left=result, right=right_operand, position=self._get_node_position(node))
                        elif operator == '!=' or operator == 'TOK_NOTEQUAL':
                            result = InequalityOp(left=result, right=right_operand, position=self._get_node_position(node))
                        else:
                            # Default to equality if unknown operator
                            result = EqualityOp(left=result, right=right_operand, position=self._get_node_position(node))
                        operand_idx += 1
        except (TypeError, AttributeError, IndexError):
            # Fallback: if we can't access raw children, default to equality
            result = children[0]
            for i in range(1, len(children)):
                result = EqualityOp(left=result, right=children[i], position=self._get_node_position(node))
        
        return result
    
    def visit_prec_comparison(self, node, children):
        # prec_comparison rule: OneOrMore(prec_binary_or, sep=[TOK_LTE, TOK_GTE, TOK_LT, TOK_GT])
        # The node structure is: [prec_binary_or, operator, prec_binary_or, operator, ...]
        # Operators are NonTerminal nodes with rule_name TOK_LT, TOK_GT, TOK_LTE, or TOK_GTE
        if len(children) == 1:
            return children[0]
        
        # Get raw node children to access operators
        try:
            node_children = list(node)
            # node_children alternates: operand, operator, operand, operator, ...
            # children list has only the operands (operators might be filtered out or included)
            result = children[0]
            operand_idx = 1  # Index into children list (operands only)
            
            for i in range(1, len(node_children), 2):  # Skip every other (operators)
                if i < len(node_children):
                    operator_node = node_children[i]
                    # Check the rule_name to determine the operator
                    if hasattr(operator_node, 'rule_name'):
                        operator_rule = operator_node.rule_name
                    else:
                        operator_rule = None  # pragma: no cover
                    
                    if operand_idx < len(children):
                        right_operand = children[operand_idx]
                        if operator_rule == 'TOK_LT':
                            result = LessThanOp(left=result, right=right_operand, position=self._get_node_position(node))
                        elif operator_rule == 'TOK_GT':
                            result = GreaterThanOp(left=result, right=right_operand, position=self._get_node_position(node))
                        elif operator_rule == 'TOK_LTE':
                            result = LessThanOrEqualOp(left=result, right=right_operand, position=self._get_node_position(node))
                        elif operator_rule == 'TOK_GTE':
                            result = GreaterThanOrEqualOp(left=result, right=right_operand, position=self._get_node_position(node))
                        else:
                            # Default to less than if unknown operator
                            result = LessThanOp(left=result, right=right_operand, position=self._get_node_position(node))
                        operand_idx += 1
        except (TypeError, AttributeError, IndexError):
            # Fallback: if we can't access raw children, default to less than
            result = children[0]
            for i in range(1, len(children)):
                result = LessThanOp(left=result, right=children[i], position=self._get_node_position(node))
        
        return result
    
    def visit_prec_binary_or(self, node, children):
        # prec_binary_or rule: OneOrMore(prec_binary_and, sep=TOK_BINARY_OR)
        # The children list contains: operands (AST nodes) and operators (NonTerminal nodes with rule_name TOK_BINARY_OR)
        # Operators are passed through from _visit_node since there's no visit_TOK_BINARY_OR method
        if len(children) == 1:
            return children[0]
        
        # Separate operands (Expression AST nodes) from operators (NonTerminal nodes with rule_name TOK_BINARY_OR)
        # The children list should alternate: operand, operator, operand, operator, ...
        # But we need to handle the case where operators might be mixed in
        operands = [child for child in children if isinstance(child, Expression)]
        operators = [child for child in children if hasattr(child, 'rule_name') and child.rule_name == 'TOK_BINARY_OR']
        
        if len(operands) == 1:
            return operands[0]  # pragma: no cover
        
        if len(operands) != len(operators) + 1:
            # Fallback: if structure is unexpected, just chain operands with bitwise or
            result = operands[0]
            for i in range(1, len(operands)):
                result = BitwiseOrOp(left=result, right=operands[i], position=self._get_node_position(node))
            return result
        
        if True:  # pragma: no cover
            result = operands[0]
            for i in range(len(operators)):
                if i + 1 < len(operands):
                    result = BitwiseOrOp(left=result, right=operands[i + 1], position=self._get_node_position(node))
            return result
        return None  # pragma: no cover
    
    def visit_prec_binary_and(self, node, children):
        # prec_binary_and rule: OneOrMore(prec_binary_shift, sep=TOK_BINARY_AND)
        # The node structure is: [prec_binary_shift, operator, prec_binary_shift, operator, ...]
        # Operators are NonTerminal nodes with rule_name TOK_BINARY_AND
        if len(children) == 1:
            return children[0]
        
        # Get raw node children to access operators
        try:
            node_children = list(node)
            result = children[0]
            operand_idx = 1  # Index into children list (operands only)
            
            for i in range(1, len(node_children), 2):  # Skip every other (operators)
                if i < len(node_children):
                    operator_node = node_children[i]
                    # Check the rule_name to determine the operator
                    if hasattr(operator_node, 'rule_name'):
                        operator_rule = operator_node.rule_name
                    else:
                        operator_rule = None  # pragma: no cover
                    
                    if operand_idx < len(children):
                        right_operand = children[operand_idx]
                        if operator_rule == 'TOK_BINARY_AND':
                            result = BitwiseAndOp(left=result, right=right_operand, position=self._get_node_position(node))
                        else:
                            # Default to bitwise and if unknown operator (shouldn't happen for prec_binary_and)
                            result = BitwiseAndOp(left=result, right=right_operand, position=self._get_node_position(node))  # pragma: no cover
                        operand_idx += 1
        except (TypeError, AttributeError, IndexError):  # pragma: no cover
            # Fallback: if we can't access raw children, default to bitwise and
            result = children[0]
            for i in range(1, len(children)):
                result = BitwiseAndOp(left=result, right=children[i], position=self._get_node_position(node))
        
        return result
    
    def visit_prec_binary_shift(self, node, children):
        # prec_binary_shift rule: OneOrMore(prec_addition, sep=[TOK_BINARY_SHIFT_LEFT, TOK_BINARY_SHIFT_RIGHT])
        # The node structure is: [prec_addition, operator, prec_addition, operator, ...]
        # Operators are NonTerminal nodes with rule_name TOK_BINARY_SHIFT_LEFT or TOK_BINARY_SHIFT_RIGHT
        if len(children) == 1:
            return children[0]
        
        # Get raw node children to access operators
        try:
            node_children = list(node)
            result = children[0]
            operand_idx = 1  # Index into children list (operands only)
            
            for i in range(1, len(node_children), 2):  # Skip every other (operators)
                if i < len(node_children):
                    operator_node = node_children[i]
                    if hasattr(operator_node, 'rule_name'):
                        operator_rule = operator_node.rule_name
                    else:
                        operator_rule = None  # pragma: no cover
                    
                    if operand_idx < len(children):
                        right_operand = children[operand_idx]
                        if operator_rule == 'TOK_BINARY_SHIFT_LEFT':
                            result = BitwiseShiftLeftOp(left=result, right=right_operand, position=self._get_node_position(node))
                        elif operator_rule == 'TOK_BINARY_SHIFT_RIGHT':
                            result = BitwiseShiftRightOp(left=result, right=right_operand, position=self._get_node_position(node))
                        else:
                            # Default to shift left if unknown operator
                            result = BitwiseShiftLeftOp(left=result, right=right_operand, position=self._get_node_position(node))  # pragma: no cover
                        operand_idx += 1
        except (TypeError, AttributeError, IndexError):  # pragma: no cover
            # Fallback: if we can't access raw children, default to shift left
            result = children[0]
            for i in range(1, len(children)):
                result = BitwiseShiftLeftOp(left=result, right=children[i], position=self._get_node_position(node))
        
        return result
    
    def visit_prec_addition(self, node, children):
        # prec_addition rule: OneOrMore(prec_multiplication, sep=['+', '-'])
        # The children list contains: operands (Expression AST nodes) and operators (Terminal nodes with values '+', '-')
        # Operators are Terminal nodes passed through from _visit_node
        if len(children) == 1:
            return children[0]
        
        # Separate operands (Expression AST nodes) from operators (Terminal nodes with values '+', '-')
        operands = [child for child in children if isinstance(child, Expression)]
        operators = [child for child in children if not isinstance(child, Expression) and not isinstance(child, ASTNode)]
        
        if len(operands) == 1:
            return operands[0]  # pragma: no cover
        
        if len(operands) != len(operators) + 1:  # pragma: no cover
            # Fallback: if structure is unexpected, just chain operands with addition
            result = operands[0]
            for i in range(1, len(operands)):
                result = AdditionOp(left=result, right=operands[i], position=self._get_node_position(node))
            return result
        
        result = operands[0]
        for i in range(len(operators)):
            if i + 1 < len(operands):
                operator = operators[i] if isinstance(operators[i], str) else (getattr(operators[i], 'value', operators[i]) if hasattr(operators[i], 'value') else str(operators[i]))
                right_operand = operands[i + 1]
                if operator == '+':
                    result = AdditionOp(left=result, right=right_operand, position=self._get_node_position(node))
                elif operator == '-':
                    result = SubtractionOp(left=result, right=right_operand, position=self._get_node_position(node))
                else:
                    # Default to addition if unknown operator
                    result = AdditionOp(left=result, right=right_operand, position=self._get_node_position(node))  # pragma: no cover
        
        return result
    
    def visit_prec_multiplication(self, node, children):
        # prec_multiplication rule: OneOrMore(prec_unary, sep=['*', '/', '%'])
        # The children list contains: operands (Expression AST nodes) and operators (Terminal nodes with values '*', '/', '%')
        # Operators are Terminal nodes passed through from _visit_node
        if len(children) == 1:
            return children[0]
        
        # Separate operands (Expression AST nodes) from operators (Terminal nodes with values '*', '/', '%')
        operands = [child for child in children if isinstance(child, Expression)]
        operators = [child for child in children if not isinstance(child, Expression) and not isinstance(child, ASTNode)]
        
        if len(operands) == 1:
            return operands[0]  # pragma: no cover
        
        if len(operands) != len(operators) + 1:  # pragma: no cover
            # Fallback: if structure is unexpected, just chain operands with multiplication
            result = operands[0]
            for i in range(1, len(operands)):
                result = MultiplicationOp(left=result, right=operands[i], position=self._get_node_position(node))
            return result
        
        result = operands[0]
        for i in range(len(operators)):
            if i + 1 < len(operands):
                operator = operators[i] if isinstance(operators[i], str) else (getattr(operators[i], 'value', operators[i]) if hasattr(operators[i], 'value') else str(operators[i]))
                right_operand = operands[i + 1]
                if operator == '*':
                    result = MultiplicationOp(left=result, right=right_operand, position=self._get_node_position(node))  # pragma: no cover
                elif operator == '/':
                    result = DivisionOp(left=result, right=right_operand, position=self._get_node_position(node))
                elif operator == '%':
                    result = ModuloOp(left=result, right=right_operand, position=self._get_node_position(node))
                else:
                    # Default to multiplication if unknown operator
                    result = MultiplicationOp(left=result, right=right_operand, position=self._get_node_position(node))
        
        return result
    
    def visit_prec_unary(self, node, children):
        # prec_unary rule: (ZeroOrMore(['+', '-', TOK_LOGICAL_NOT, TOK_BINARY_NOT]), prec_exponent)
        # The node structure is: [operator1, operator2, ..., prec_exponent]
        # But Terminal nodes (operators) return None from _visit_node, so we need to access raw children
        exprs = [child for child in children if isinstance(child, Expression)]
        if not exprs:  # pragma: no cover
            raise ValueError("prec_unary should have an Expression child")
        result = exprs[0]
        
        # Get raw node children to access operators
        try:
            node_children = list(node)
            # Operators are all Terminal nodes before the last child (which is prec_exponent)
            ops = []
            for i in range(len(node_children) - 1):  # All but the last child are operators
                operator_node = node_children[i]
                if hasattr(operator_node, 'value'):
                    op = operator_node.value
                elif hasattr(operator_node, 'rule_name'):
                    # Handle TOK_LOGICAL_NOT and TOK_BINARY_NOT
                    if operator_node.rule_name == 'TOK_LOGICAL_NOT':
                        op = '!'
                    elif operator_node.rule_name == 'TOK_BINARY_NOT':
                        op = '~'
                    else:  # pragma: no cover
                        op = str(operator_node)
                else:  # pragma: no cover
                    op = str(operator_node)
                ops.append(op)
            
            # Apply operators right-to-left (last operator first)
            for op in reversed(ops):
                if op == '-':
                    result = UnaryMinusOp(expr=result, position=self._get_node_position(node))
                elif op == '!':
                    result = LogicalNotOp(expr=result, position=self._get_node_position(node))
                elif op == '~':
                    result = BitwiseNotOp(expr=result, position=self._get_node_position(node))
                # '+' does nothing (unary plus)
        except (TypeError, AttributeError, IndexError):
            # Fallback: try to find operators in children (old behavior)
            ops = [child for child in children if isinstance(child, str) and child in ['+', '-', '!', '~']]
            for op in reversed(ops):
                if op == '-':
                    result = UnaryMinusOp(expr=result, position=self._get_node_position(node))
                elif op == '!':
                    result = LogicalNotOp(expr=result, position=self._get_node_position(node))
                elif op == '~':
                    result = BitwiseNotOp(expr=result, position=self._get_node_position(node))
        
        return result
    
    def visit_prec_exponent(self, node, children):
        # prec_exponent rule: [(prec_call, '^', prec_unary), prec_call]
        operands = [child for child in children if isinstance(child, Expression)]
        if len(operands) == 1:
            return operands[0]
        if not operands:  # pragma: no cover
            return children[0] if children else None
        # Right-associative: a^b^c = a^(b^c)
        result = operands[-1]
        for i in range(len(operands) - 2, -1, -1):
            result = ExponentOp(left=operands[i], right=result, position=self._get_node_position(node))
        return result
    
    def visit_prec_call(self, node, children):
        # prec_call rule: (primary, ZeroOrMore([call_expr, lookup_expr, member_expr]))
        if len(children) == 1:
            return children[0]
        result = children[0]
        if not isinstance(result, Expression):
            # If first child is not an Expression, we can't proceed
            return result  # pragma: no cover
        # Process suffixes left-to-right
        # The children after the first are tuples: ('call', args), ('index', expr), or ('member', identifier)
        for i in range(1, len(children)):
            child = children[i]
            if isinstance(child, tuple) and len(child) == 2:
                op_type, op_value = child
                if op_type == 'call':
                    arguments = op_value if isinstance(op_value, list) else [op_value] if isinstance(op_value, Argument) else []
                    result = PrimaryCall(left=result, arguments=arguments, position=self._get_node_position(node))
                elif op_type == 'index':
                    if isinstance(op_value, Expression):
                        result = PrimaryIndex(left=result, index=op_value, position=self._get_node_position(node))
                elif op_type == 'member':
                    if isinstance(op_value, Identifier):
                        result = PrimaryMember(left=result, member=op_value, position=self._get_node_position(node))
            elif isinstance(child, Expression):  # pragma: no cover
                # Fallback: if it's already an Expression, use it directly
                result = child
        return result
    
    def visit_call_expr(self, node, children):
        # call_expr rule: (argument_block,)
        # children already holds argument list items
        return ('call', list(children))
    
    def visit_lookup_expr(self, node, children):
        # lookup_expr rule: (TOK_BRACKET, expr, TOK_ENDBRACKET)
        return ('index', children[0] if children else None)
    
    def visit_member_expr(self, node, children):
        # member_expr rule: (TOK_PERIOD, member_name)
        return ('member', children[0] if children else None)
    
    def visit_paren_expr(self, node, children):
        return children[0]
    
    def visit_primary(self, node, children):
        return children[0]
    
    def visit_range_expr(self, node, children):
        start = children[0]
        end = children[1]
        # Step is optional - if present, use it; otherwise default to 1.0
        step = children[2] if len(children) > 2 else NumberLiteral(val=1.0, position=self._get_node_position(node))
        return RangeLiteral(start=start, end=end, step=step, position=self._get_node_position(node))
    
    def visit_vector_expr(self, node, children):
        elements = children[0] if children else []
        if elements is None:  # pragma: no cover
            elements = []
        if not isinstance(elements, list):
            elements = [elements]
        return ListComprehension(elements=elements, position=self._get_node_position(node))
    
    def visit_funclit_def(self, node, children):
        return FunctionLiteral(arguments=children[0], body=children[1], position=self._get_node_position(node))
    
    def visit_vector_elements(self, node, children):
        return list(children) if children else []
    
    def visit_vector_element(self, node, children):
        return children[0]
    
    def visit_listcomp_elements(self, node, children):
        return children[0]

    def visit_listcomp_paren_expr(self, node, children):
        return children[0] if children else None
    
    def visit_listcomp_let(self, node, children):
        return ListCompLet(assignments=children[0], body=children[1], position=self._get_node_position(node))
    
    def visit_listcomp_each(self, node, children):
        return ListCompEach(body=children[0], position=self._get_node_position(node))
    
    def visit_listcomp_for(self, node, children):
        return ListCompFor(
            assignments=children[0],
            body=children[1],
            position=self._get_node_position(node)
        )

    def visit_listcomp_c_for(self, node, children):
        return ListCompCFor(
            initial=children[0],
            condition=children[1],
            increment=children[2],
            body=children[3],
            position=self._get_node_position(node)
        )
    
    def visit_listcomp_ifelse(self, node, children):
        return ListCompIfElse(
            condition=children[0],
            true_expr=children[1],
            false_expr=children[2],
            position=self._get_node_position(node)
        )

    def visit_listcomp_ifonly(self, node, children):
        return ListCompIf(
            condition=children[0],
            true_expr=children[1],
            position=self._get_node_position(node)
        )
    
    def visit_modular_call(self, node, children):
        name = children[0] if children else None
        if name is None:  # pragma: no cover
            raise ValueError("modular_call should have a module name")
        if not isinstance(name, Identifier):
            name = Identifier(name=str(name), position=self._get_node_position(node))
        if hasattr(children, "arguments") and children.arguments:
            arguments = children.arguments[0]
        else:
            arguments = children[1] if len(children) > 1 else []
        if arguments is None:  # pragma: no cover
            arguments = []
        if not isinstance(arguments, list):  # pragma: no cover
            arguments = [arguments]
        if hasattr(children, "child_statement") and children.child_statement:
            mods = children.child_statement[0]
        else:
            mods = children[2] if len(children) > 2 else []
        if mods is None:  # pragma: no cover
            mods = []
        if not isinstance(mods, list):
            mods = [mods]
        return ModularCall(
            name=name,
            arguments=arguments,
            children=mods,
            position=self._get_node_position(node)
        )
    
    def visit_modular_c_for(self, node, children):
        initial = children[0] if isinstance(children[0], list) else [children[0]]
        increment = children[2] if isinstance(children[2], list) else [children[2]]
        return ModularCFor(
            initial=initial,
            condition=children[1],
            increment=increment,
            body=children[3],
            position=self._get_node_position(node)
        )
    
    def visit_modular_for(self, node, children):
        assignments = children[0] if isinstance(children[0], list) else [children[0]]
        return ModularFor(
            assignments=assignments,
            body=children[1],
            position=self._get_node_position(node)
        )
    
    def visit_modular_intersection_c_for(self, node, children):
        initial = children[0] if isinstance(children[0], list) else [children[0]]
        increment = children[2] if isinstance(children[2], list) else [children[2]]
        return ModularIntersectionCFor(
            initial=initial,
            condition=children[1],
            increment=increment,
            body=children[3],
            position=self._get_node_position(node)
        )

    def visit_modular_intersection_for(self, node, children):
        assignments = children[0] if isinstance(children[0], list) else [children[0]]
        return ModularIntersectionFor(assignments=assignments, body=children[1], position=self._get_node_position(node))
    
    def visit_modular_let(self, node, children):
        assignments = children[0] if isinstance(children[0], list) else [children[0]]
        mods = children[1] if isinstance(children[1], list) else [children[1]]
        return ModularLet(assignments=assignments, children=mods, position=self._get_node_position(node))
    
    def visit_modular_echo(self, node, children):
        arguments = children[0] if isinstance(children[0], list) else [children[0]]
        mods = children[1] if isinstance(children[1], list) else [children[1]]
        return ModularEcho(arguments=arguments, children=mods, position=self._get_node_position(node))
    
    def visit_modular_assert(self, node, children):
        arguments = children[0] if isinstance(children[0], list) else [children[0]]
        mods = children[1] if isinstance(children[1], list) else [children[1]]
        return ModularAssert(arguments=arguments, children=mods, position=self._get_node_position(node))
    
    def visit_if_statement(self, node, children):
        return ModularIf(condition=children[0], true_branch=children[1], position=self._get_node_position(node))
    
    def visit_ifelse_statement(self, node, children):
        return ModularIfElse(condition=children[0], true_branch=children[1], false_branch=children[2], position=self._get_node_position(node))
    
    def visit_modifier_show_only(self, node, children):
        child = children[0]  # We know modifiers can only have one child.
        return ModularModifierShowOnly(child=child, position=self._get_node_position(node))
    
    def visit_modifier_highlight(self, node, children):
        child = children[0]  # We know modifiers can only have one child.
        return ModularModifierHighlight(child=child, position=self._get_node_position(node))
    
    def visit_modifier_background(self, node, children):
        child = children[0]  # We know modifiers can only have one child.
        return ModularModifierBackground(child=child, position=self._get_node_position(node))
    
    def visit_modifier_disable(self, node, children):
        child = children[0]  # We know modifiers can only have one child.
        return ModularModifierDisable(child=child, position=self._get_node_position(node))
    
    def visit_assignment(self, node, children):
        # Grammar: (variable_name, TOK_ASSIGN, expr, TOK_SEMICOLON)
        # After visiting: [Identifier, expr] (TOK_ASSIGN and TOK_SEMICOLON return None)
        return Assignment(name=children[0], expr=children[1], position=self._get_node_position(node))
    
    def visit_comment_line(self, node, children):
        # Grammar: _(r'//.*?$', str_repr='comment')
        # The regex match contains the full comment including //
        text = node.value if hasattr(node, 'value') else (children[0] if children else "")
        # Remove the // prefix if present
        if text.startswith("//"):
            text = text[2:]
        return CommentLine(text=text, position=self._get_node_position(node))
    
    def visit_comment_multi(self, node, children):
        # Grammar: _(r'(?ms)/\*.*?\*/', str_repr='comment')
        # The regex match contains the full comment including /* and */
        text = node.value if hasattr(node, 'value') else (children[0] if children else "")
        # Remove the /* prefix and */ suffix if present
        if text.startswith("/*"):
            text = text[2:]
        if text.endswith("*/"):
            text = text[:-2]
        return CommentSpan(text=text, position=self._get_node_position(node))
    
    def visit_comment(self, node, children):
        return children[0]
    
    def visit_empty_statement(self, node, children):
        return []

    def visit_statement_block(self, node, children):
        return list(children)

    def visit_statement(self, node, children):
        # Grammar: [empty_statement, statement_block, module_definition, function_definition, module_instantiation, assignment]
        # Return the first child if available
        if not children:
            return None
        if len(children) == 1:
            return children[0]
        return list(children)
    
    def visit_module_instantiation(self, node, children):
        if not children:
            raise ValueError("module_instantiation should have at least one child")
        return children[0]
    
    def visit_single_module_instantiation(self, node, children):
        if not children:
            raise ValueError("single_module_instantiation should have at least one child")
        return children[0]
    
    def visit_child_statement(self, node, children):
        # Grammar: [empty_statement, statement_block, module_instantiation]
        # Return the first child if available
        return children[0] if children else None
    
    def visit_expr(self, node, children) -> Expression:
        if not children:
            raise ValueError("expr should have at least one child")
        return children[0]
    
    def visit_toplevel_statement(self, node, children) -> ASTNode:
        return children[0]
    
    def visit_toplevel_statement_or_comment(self, node, children) -> ASTNode:
        return children[0]
    
    def visit_EOF(self, node, children):
        return None
    
    def visit_openscad_language(self, node, children) -> list[ASTNode]:
        return list(children)
    
    def visit_openscad_language_with_comments(self, node, children) -> list[ASTNode]:
        return list(children)

