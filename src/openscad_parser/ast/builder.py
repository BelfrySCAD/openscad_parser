from dataclasses import dataclass
from arpeggio import PTNodeVisitor
from typing import Optional

from .source_map import SourceMap
from .nodes import *


@dataclass
class Position:
    """Represents a position in source code.
    
    Stores only the character position and input string. Line and column are
    calculated lazily when accessed via the line and char properties.
    """
    file: str
    position: int  # Character position (0-indexed)
    input_str: str = ""  # Input string for lazy line/column calculation
    
    def _calculate_line_col(self) -> tuple[int, int]:
        """Calculate (line, column) tuple from character position.
        
        Returns:
            Tuple of (line_number, column_number), both 1-indexed
        """
        if not self.input_str or self.position < 0 or self.position > len(self.input_str):
            return (1, 1)
        
        # Count newlines before this position
        text_before = self.input_str[:self.position]
        line_number = text_before.count('\n') + 1
        
        # Find the column (character position on the current line)
        last_newline = text_before.rfind('\n')
        column_number = self.position - last_newline  # 1-indexed
        
        return (line_number, column_number)
    
    @property
    def line(self) -> int:
        """Get the line number (1-indexed) for this position (lazy evaluation)."""
        return self._calculate_line_col()[0]
    
    @property
    def char(self) -> int:
        """Get the column number (1-indexed) for this position (lazy evaluation)."""
        return self._calculate_line_col()[1]


class ASTBuilderVisitor(PTNodeVisitor):
    """
    Visits the parse tree generated by the PEG grammar in __init__.py and builds the AST defined in ast.py.
    """
    
    def __init__(self, parser, source_map=None, file=""):
        """Initialize the visitor with the parser and optional source map or file path.
        
        Args:
            parser: The Arpeggio parser instance (needed to access input for position conversion)
            source_map: Optional SourceMap for tracking positions across multiple origins
            file: Optional file path for source location tracking (deprecated, use source_map)
        """
        super().__init__()
        self.parser = parser
        if source_map is not None:
            self.source_map = source_map
            self.file = ""  # Not used when source_map is provided
        else:
            # Backward compatibility: create a simple source map from file
            self.source_map = SourceMap()
            if file:
                # We can't get the content here, but we'll handle it in _get_node_position
                self.file = file
            else:
                self.file = ""
    
    def visit_parse_tree(self, parse_tree):
        """Visit a parse tree and return the AST.
        
        This is the main entry point for converting a parse tree to an AST.
        
        Args:
            parse_tree: The root node of an Arpeggio parse tree
            
        Returns:
            The root AST node (or list of AST nodes for the root level)
        """
        return self._visit_node(parse_tree)
    
    def _visit_node(self, node):
        """Recursively visit a parse tree node and return AST.
        
        This method handles the visitor pattern for Arpeggio parse trees.
        Terminal nodes are passed through as their values, and NonTerminal nodes
        are visited using their rule_name to find the appropriate visit method.
        NonTerminal nodes without visit methods are passed through as the node itself.
        
        Args:
            node: An Arpeggio parse tree node
            
        Returns:
            The AST node (or list of AST nodes) for this parse tree node,
            or the node/value itself if it should be passed through
        """
        if node is None:
            return None
        
        # Get the rule name for this node
        if not hasattr(node, 'rule_name'):
            # Terminal node - return its value so parent can use it directly
            return getattr(node, 'value', node)
        
        rule_name = node.rule_name
        
        # Visit children first
        # Arpeggio's NonTerminal objects are iterable, so iterate directly
        children = []
        try:
            # Try to iterate over the node (Arpeggio NonTerminal objects are iterable)
            for child in node:
                child_ast = self._visit_node(child)
                if child_ast is not None:
                    # If child_ast is a list, extend; otherwise append
                    if isinstance(child_ast, list):
                        children.extend(child_ast)
                    else:
                        children.append(child_ast)
        except (TypeError, AttributeError):
            # Node is not iterable, skip children
            pass
        
        # Call the appropriate visit method
        visit_method_name = f"visit_{rule_name}"
        visit_method = getattr(self, visit_method_name, None)
        if visit_method:
            try:
                return visit_method(node, children)
            except Exception as e:
                # If visit method fails, return children or None
                return children if children else None
        else:
            # No visit method - pass through the node itself so parent can access rule_name/value
            # This is useful for operator nodes like TOK_BINARY_OR, TOK_EQUAL, etc.
            return node
    
    def _get_node_position(self, node):
        """Extract position information from an Arpeggio parse tree node.
        
        Uses SourceMap to map positions back to original origins if available.
        
        Args:
            node: Arpeggio parse tree node
            
        Returns:
            Position object for the node
        """
        input_str = self.parser.input if hasattr(self.parser, 'input') else ""
        if hasattr(node, 'position'):
            char_pos = node.position
        else:
            char_pos = 0
        
        # Use SourceMap if available to map position back to original origin
        if hasattr(self, 'source_map') and self.source_map.get_segments():
            location = self.source_map.get_location(char_pos)
            return Position(file=location.origin, position=char_pos, input_str=input_str)
        else:
            # Fallback to file parameter for backward compatibility
            return Position(file=self.file, position=char_pos, input_str=input_str)

    def visit_TOK_ID(self, node, children):
        # Prefer the last child for value (to avoid list-wrapping problems)
        value = children[-1] if children else node.value
        return Identifier(
            name=value,
            position=self._get_node_position(node)
        )

    def visit_TOK_STRING(self, node, children):
        # TOK_STRING has 3 children: opening quote, string content, closing quote
        # We want the middle child (index 1) which is the actual string content
        # Terminal nodes do not return None from _visit_node anymore; children should directly contain values.
        # We prefer children[1] as the string content if available.
        if len(children) >= 2:
            value = children[1]
        else:
            # Fallback: try to extract string content from node.value
            value = node.value
            if isinstance(value, str):
                # Extract the middle part if node.value is like '" | hello | "'
                parts = value.split(' | ')
                if len(parts) == 3:
                    value = parts[1]
                elif value.startswith('"') and value.endswith('"'):
                    value = value.strip('"')
        return StringLiteral(
            val=value,
            position=self._get_node_position(node)
        )

    def visit_TOK_NUMBER(self, node, children):
        value = children[-1] if children else node.value
        return NumberLiteral(
            val=float(value),
            position=self._get_node_position(node)
        )
    
    def visit_TOK_TRUE(self, node, children):
        return BooleanLiteral(
            val=True,
            position=self._get_node_position(node)
        )

    def visit_TOK_FALSE(self, node, children):
        return BooleanLiteral(
            val=False,
            position=self._get_node_position(node)
        )

    def visit_TOK_UNDEF(self, node, children):
        return UndefinedLiteral(position=self._get_node_position(node))
    
    def visit_module_definition(self, node, children):
        # module_definition rule: (TOK_MODULE, TOK_ID, '(', parameters, ')', statement)
        # After visiting, children structure: [name (Identifier), parameters (list or None), statement (body)]
        # Terminal nodes (TOK_MODULE, '(', ')') return None, so they're filtered out
        
        # Find name (Identifier)
        name = None
        for child in children:
            if isinstance(child, Identifier):
                name = child
                break
        
        if name is None:
            raise ValueError("module_definition should have a name (Identifier)")
        
        # Find parameters (list of ParameterDeclaration)
        # Parameters could be:
        # 1. A list of ParameterDeclaration nodes (from visit_parameters)
        # 2. Individual ParameterDeclaration nodes
        params = []
        for child in children:
            if isinstance(child, list):
                # List of parameters
                params.extend([item for item in child if isinstance(item, ParameterDeclaration)])
            elif isinstance(child, ParameterDeclaration):
                # Single parameter
                params.append(child)
        
        # Find statement body and extract module instantiations
        # The statement body could be:
        # 1. A single statement (ModuleInstantiation, Assignment, etc.)
        # 2. A list of statements (from a block '{ ... }')
        mods = []
        for child in children:
            if isinstance(child, ModuleInstantiation):
                # Direct module instantiation
                mods.append(child)
            elif isinstance(child, list):
                # Block of statements
                for item in child:
                    if isinstance(item, ModuleInstantiation):
                        mods.append(item)
                    elif isinstance(item, list):
                        # Nested lists (from nested blocks)
                        for nested_item in item:
                            if isinstance(nested_item, ModuleInstantiation):
                                mods.append(nested_item)
            # Note: Assignment nodes are not included in children, only ModuleInstantiation nodes
        
        return ModuleDeclaration(
            name=name,
            parameters=params,
            children=mods,
            position=self._get_node_position(node)
        )

    def visit_function_definition(self, node, children):
        # function_definition rule: (TOK_FUNCTION, TOK_ID, '(', parameters, ')', TOK_ASSIGN, expr, ';')
        # After visiting, children are: [Terminal (TOK_FUNCTION), Identifier (name), Terminal ('('), 
        #   ParameterDeclaration, ..., ParameterDeclaration, Terminal (')'), Terminal (TOK_ASSIGN), 
        #   Expression (expr), Terminal (';')]
        # Terminal nodes are now passed through from _visit_node, so we need to filter them out
        
        # Get the name (should be an Identifier)
        name = None
        for child in children:
            if isinstance(child, Identifier):
                name = child
                break
        
        if name is None:
            raise ValueError("FunctionDeclarationNode should have an Identifier child for the name")
        
        # Collect all ParameterDeclaration nodes (they come after the name)
        params = [item for item in children if isinstance(item, ParameterDeclaration)]
        
        # Get the expression (should be an Expression that's not the Identifier name)
        # Filter for Expression instances, excluding the Identifier name
        expr_candidates = [item for item in children if isinstance(item, Expression) and item is not name]
        expr = expr_candidates[-1] if expr_candidates else None
        if expr is None:
            raise ValueError("FunctionDeclarationNode should have an Expression child")
        
        return FunctionDeclaration(
            name=name,
            parameters=params,
            expr=expr,
            position=self._get_node_position(node)
        )
    
    def visit_use_statement(self, node, children):
        # use_statement rule: (TOK_USE, '<', _(r'[^>]+'), '>')
        # The filepath is at index 2 in the raw node children (the regex match)
        # Terminal nodes return None from _visit_node, so we need to access raw children
        try:
            node_children = list(node)
            if len(node_children) >= 3:
                # node_children[2] is the Terminal node with the filepath
                filepath_value = node_children[2].value if hasattr(node_children[2], 'value') else str(node_children[2])
                filepath = StringLiteral(val=filepath_value, position=self._get_node_position(node_children[2]))
            else:
                raise ValueError("UseStatementNode should have a filepath at index 2")
        except (TypeError, AttributeError, IndexError):
            # Fallback: try to find StringLiteral in children
            strlits = [child for child in children if isinstance(child, StringLiteral)]
            if strlits:
                filepath = strlits[0]
            else:
                raise ValueError("UseStatementNode should have a filepath")
        
        return UseStatement(
            filepath=filepath,
            position=self._get_node_position(node)
        )
    
    def visit_include_statement(self, node, children):
        # include_statement rule: (TOK_INCLUDE, '<', _(r'[^>]+'), '>')
        # The filepath is at index 2 in the raw node children (the regex match)
        # Terminal nodes return None from _visit_node, so we need to access raw children
        try:
            node_children = list(node)
            if len(node_children) >= 3:
                # node_children[2] is the Terminal node with the filepath
                filepath_value = node_children[2].value if hasattr(node_children[2], 'value') else str(node_children[2])
                filepath = StringLiteral(val=filepath_value, position=self._get_node_position(node_children[2]))
            else:
                raise ValueError("IncludeStatementNode should have a filepath at index 2")
        except (TypeError, AttributeError, IndexError):
            # Fallback: try to find StringLiteral in children
            strlits = [child for child in children if isinstance(child, StringLiteral)]
            if strlits:
                filepath = strlits[0]
            else:
                raise ValueError("IncludeStatementNode should have a filepath")
        
        return IncludeStatement(
            filepath=filepath,
            position=self._get_node_position(node)
        )

    def visit_parameters(self, node, children):
        # parameters rule: (ZeroOrMore(parameter, sep=TOK_COMMA), ZeroOrMore(TOK_COMMA))
        # Collect all ParameterDeclaration nodes, filtering out commas and empty elements
        params = [child for child in children if isinstance(child, ParameterDeclaration)]
        return params
    
    def visit_parameter(self, node, children):
        # parameter rule: [(TOK_ID, TOK_ASSIGN, expr), TOK_ID]
        if len(children) == 1:
            # Just TOK_ID - no default value
            name = children[0] if isinstance(children[0], Identifier) else Identifier(name=children[0], position=self._get_node_position(node))
            return ParameterDeclaration(name=name, default=None, position=self._get_node_position(node))
        else:
            # TOK_ID, TOK_ASSIGN, expr
            name = children[0] if isinstance(children[0], Identifier) else Identifier(name=children[0], position=self._get_node_position(node))
            default_expr = [child for child in children[1:] if isinstance(child, Expression)]
            default = default_expr[0] if default_expr else None
            return ParameterDeclaration(name=name, default=default, position=self._get_node_position(node))
    
    def visit_arguments(self, node, children):
        # arguments rule: (ZeroOrMore(argument, sep=TOK_COMMA), Optional(TOK_COMMA))
        # Collect all Argument nodes (PositionalArgument or NamedArgument), filtering out commas
        args = [child for child in children if isinstance(child, Argument)]
        return args
    
    def visit_argument(self, node, children):
        # argument rule: [(TOK_ID, TOK_ASSIGN, expr), expr]
        if len(children) == 1:
            # Just expr - positional argument
            expr = children[0] if isinstance(children[0], Expression) else None
            if expr is None:
                raise ValueError("argument should have an Expression child")
            return PositionalArgument(expr=expr, position=self._get_node_position(node))
        else:
            # TOK_ID, TOK_ASSIGN, expr - named argument
            name = children[0] if isinstance(children[0], Identifier) else Identifier(name=children[0], position=self._get_node_position(node))
            expr = [child for child in children[1:] if isinstance(child, Expression)]
            if not expr:
                raise ValueError("named argument should have an Expression child")
            return NamedArgument(name=name, expr=expr[0], position=self._get_node_position(node))
    
    def visit_assignments_expr(self, node, children):
        # assignments_expr rule: (ZeroOrMore(assignment_expr, sep=TOK_COMMA), Optional(TOK_COMMA))
        # Collect all Assignment nodes, filtering out commas
        assignments = [child for child in children if isinstance(child, Assignment)]
        return assignments
    
    def visit_assignment_expr(self, node, children):
        # assignment_expr rule: (TOK_ID, TOK_ASSIGN, expr)
        name = children[0] if isinstance(children[0], Identifier) else Identifier(name=children[0], position=self._get_node_position(node))
        expr = [child for child in children[1:] if isinstance(child, Expression)]
        if not expr:
            raise ValueError("assignment_expr should have an Expression child")
        return Assignment(name=name, expr=expr[0], position=self._get_node_position(node))
    
    def visit_let_expr(self, node, children):
        # let_expr rule: (TOK_LET, '(', assignments_expr, ')', expr)
        # children: assignments list, expr
        assignments = [child for child in children if isinstance(child, Assignment)]
        expr = [child for child in children if isinstance(child, Expression) and not isinstance(child, Assignment)]
        if not expr:
            raise ValueError("let_expr should have an Expression body")
        return LetOp(assignments=assignments, body=expr[0], position=self._get_node_position(node))
    
    def visit_assert_expr(self, node, children):
        # assert_expr rule: (TOK_ASSERT, '(', arguments, ')', Optional(expr))
        arguments = [child for child in children if isinstance(child, Argument)]
        expr = [child for child in children if isinstance(child, Expression) and not isinstance(child, Argument)]
        body = expr[0] if expr else None
        if body is None:
            raise ValueError("assert_expr should have an Expression body")
        return AssertOp(arguments=arguments, body=body, position=self._get_node_position(node))
    
    def visit_echo_expr(self, node, children):
        # echo_expr rule: (TOK_ECHO, '(', arguments, ')', Optional(expr))
        arguments = [child for child in children if isinstance(child, Argument)]
        expr = [child for child in children if isinstance(child, Expression) and not isinstance(child, Argument)]
        body = expr[0] if expr else None
        if body is None:
            raise ValueError("echo_expr should have an Expression body")
        return EchoOp(arguments=arguments, body=body, position=self._get_node_position(node))
    
    def visit_ternary_expr(self, node, children):
        # ternary_expr rule: (prec_logical_or, '?', expr, ':', expr)
        # children: condition, true_expr, false_expr
        exprs = [child for child in children if isinstance(child, Expression)]
        if len(exprs) != 3:
            raise ValueError("ternary_expr should have 3 Expression children (condition, true, false)")
        return TernaryOp(condition=exprs[0], true_expr=exprs[1], false_expr=exprs[2], position=self._get_node_position(node))
    
    def visit_prec_logical_or(self, node, children):
        # prec_logical_or rule: OneOrMore(prec_logical_and, sep=TOK_LOGICAL_OR)
        # Build left-associative tree
        if len(children) == 1:
            return children[0]
        result = children[0]
        for i in range(1, len(children)):
            result = LogicalOrOp(left=result, right=children[i], position=self._get_node_position(node))
        return result
    
    def visit_prec_logical_and(self, node, children):
        # prec_logical_and rule: OneOrMore(prec_equality, sep=TOK_LOGICAL_AND)
        if len(children) == 1:
            return children[0]
        result = children[0]
        for i in range(1, len(children)):
            result = LogicalAndOp(left=result, right=children[i], position=self._get_node_position(node))
        return result
    
    def visit_prec_equality(self, node, children):
        # prec_equality rule: OneOrMore(prec_comparison, sep=[TOK_EQUAL, TOK_NOTEQUAL])
        # The node structure is: [prec_comparison, operator, prec_comparison, operator, ...]
        # But Terminal nodes (operators) return None from _visit_node, so we need to access raw children
        if len(children) == 1:
            return children[0]
        
        # Get raw node children to access operators
        try:
            node_children = list(node)
            # node_children alternates: operand, operator, operand, operator, ...
            # children list has only the operands (Terminal nodes filtered out)
            result = children[0]
            operand_idx = 1  # Index into children list (operands only)
            
            for i in range(1, len(node_children), 2):  # Skip every other (operators)
                if i < len(node_children):
                    operator_node = node_children[i]
                    # Check if it's TOK_EQUAL or TOK_NOTEQUAL
                    if hasattr(operator_node, 'rule_name'):
                        if operator_node.rule_name == 'TOK_EQUAL':
                            operator = '=='
                        elif operator_node.rule_name == 'TOK_NOTEQUAL':
                            operator = '!='
                        else:
                            operator = operator_node.value if hasattr(operator_node, 'value') else str(operator_node)
                    else:
                        operator = operator_node.value if hasattr(operator_node, 'value') else str(operator_node)
                    
                    if operand_idx < len(children):
                        right_operand = children[operand_idx]
                        if operator == '==' or operator == 'TOK_EQUAL':
                            result = EqualityOp(left=result, right=right_operand, position=self._get_node_position(node))
                        elif operator == '!=' or operator == 'TOK_NOTEQUAL':
                            result = InequalityOp(left=result, right=right_operand, position=self._get_node_position(node))
                        else:
                            # Default to equality if unknown operator
                            result = EqualityOp(left=result, right=right_operand, position=self._get_node_position(node))
                        operand_idx += 1
        except (TypeError, AttributeError, IndexError):
            # Fallback: if we can't access raw children, default to equality
            result = children[0]
            for i in range(1, len(children)):
                result = EqualityOp(left=result, right=children[i], position=self._get_node_position(node))
        
        return result
    
    def visit_prec_comparison(self, node, children):
        # prec_comparison rule: OneOrMore(prec_binary_or, sep=[TOK_LTE, TOK_GTE, TOK_LT, TOK_GT])
        # The node structure is: [prec_binary_or, operator, prec_binary_or, operator, ...]
        # Operators are NonTerminal nodes with rule_name TOK_LT, TOK_GT, TOK_LTE, or TOK_GTE
        if len(children) == 1:
            return children[0]
        
        # Get raw node children to access operators
        try:
            node_children = list(node)
            # node_children alternates: operand, operator, operand, operator, ...
            # children list has only the operands (operators might be filtered out or included)
            result = children[0]
            operand_idx = 1  # Index into children list (operands only)
            
            for i in range(1, len(node_children), 2):  # Skip every other (operators)
                if i < len(node_children):
                    operator_node = node_children[i]
                    # Check the rule_name to determine the operator
                    if hasattr(operator_node, 'rule_name'):
                        operator_rule = operator_node.rule_name
                    else:
                        operator_rule = None
                    
                    if operand_idx < len(children):
                        right_operand = children[operand_idx]
                        if operator_rule == 'TOK_LT':
                            result = LessThanOp(left=result, right=right_operand, position=self._get_node_position(node))
                        elif operator_rule == 'TOK_GT':
                            result = GreaterThanOp(left=result, right=right_operand, position=self._get_node_position(node))
                        elif operator_rule == 'TOK_LTE':
                            result = LessThanOrEqualOp(left=result, right=right_operand, position=self._get_node_position(node))
                        elif operator_rule == 'TOK_GTE':
                            result = GreaterThanOrEqualOp(left=result, right=right_operand, position=self._get_node_position(node))
                        else:
                            # Default to less than if unknown operator
                            result = LessThanOp(left=result, right=right_operand, position=self._get_node_position(node))
                        operand_idx += 1
        except (TypeError, AttributeError, IndexError):
            # Fallback: if we can't access raw children, default to less than
            result = children[0]
            for i in range(1, len(children)):
                result = LessThanOp(left=result, right=children[i], position=self._get_node_position(node))
        
        return result
    
    def visit_prec_binary_or(self, node, children):
        # prec_binary_or rule: OneOrMore(prec_binary_and, sep=TOK_BINARY_OR)
        # The children list contains: operands (AST nodes) and operators (NonTerminal nodes with rule_name TOK_BINARY_OR)
        # Operators are passed through from _visit_node since there's no visit_TOK_BINARY_OR method
        if len(children) == 1:
            return children[0]
        
        # Separate operands (Expression AST nodes) from operators (NonTerminal nodes with rule_name TOK_BINARY_OR)
        # The children list should alternate: operand, operator, operand, operator, ...
        # But we need to handle the case where operators might be mixed in
        operands = [child for child in children if isinstance(child, Expression)]
        operators = [child for child in children if hasattr(child, 'rule_name') and child.rule_name == 'TOK_BINARY_OR']
        
        if len(operands) == 1:
            return operands[0]
        
        if len(operands) != len(operators) + 1:
            # Fallback: if structure is unexpected, just chain operands with bitwise or
            result = operands[0]
            for i in range(1, len(operands)):
                result = BitwiseOrOp(left=result, right=operands[i], position=self._get_node_position(node))
            return result
        
        result = operands[0]
        for i in range(len(operators)):
            if i + 1 < len(operands):
                result = BitwiseOrOp(left=result, right=operands[i + 1], position=self._get_node_position(node))
        
        return result
    
    def visit_prec_binary_and(self, node, children):
        # prec_binary_and rule: OneOrMore(prec_binary_shift, sep=TOK_BINARY_AND)
        # The node structure is: [prec_binary_shift, operator, prec_binary_shift, operator, ...]
        # Operators are NonTerminal nodes with rule_name TOK_BINARY_AND
        if len(children) == 1:
            return children[0]
        
        # Get raw node children to access operators
        try:
            node_children = list(node)
            result = children[0]
            operand_idx = 1  # Index into children list (operands only)
            
            for i in range(1, len(node_children), 2):  # Skip every other (operators)
                if i < len(node_children):
                    operator_node = node_children[i]
                    # Check the rule_name to determine the operator
                    if hasattr(operator_node, 'rule_name'):
                        operator_rule = operator_node.rule_name
                    else:
                        operator_rule = None
                    
                    if operand_idx < len(children):
                        right_operand = children[operand_idx]
                        if operator_rule == 'TOK_BINARY_AND':
                            result = BitwiseAndOp(left=result, right=right_operand, position=self._get_node_position(node))
                        else:
                            # Default to bitwise and if unknown operator (shouldn't happen for prec_binary_and)
                            result = BitwiseAndOp(left=result, right=right_operand, position=self._get_node_position(node))
                        operand_idx += 1
        except (TypeError, AttributeError, IndexError):
            # Fallback: if we can't access raw children, default to bitwise and
            result = children[0]
            for i in range(1, len(children)):
                result = BitwiseAndOp(left=result, right=children[i], position=self._get_node_position(node))
        
        return result
    
    def visit_prec_binary_shift(self, node, children):
        # prec_binary_shift rule: OneOrMore(prec_addition, sep=[TOK_BINARY_SHIFT_LEFT, TOK_BINARY_SHIFT_RIGHT])
        # The node structure is: [prec_addition, operator, prec_addition, operator, ...]
        # Operators are NonTerminal nodes with rule_name TOK_BINARY_SHIFT_LEFT or TOK_BINARY_SHIFT_RIGHT
        if len(children) == 1:
            return children[0]
        
        # Get raw node children to access operators
        try:
            node_children = list(node)
            result = children[0]
            operand_idx = 1  # Index into children list (operands only)
            
            for i in range(1, len(node_children), 2):  # Skip every other (operators)
                if i < len(node_children):
                    operator_node = node_children[i]
                    if hasattr(operator_node, 'rule_name'):
                        operator_rule = operator_node.rule_name
                    else:
                        operator_rule = None
                    
                    if operand_idx < len(children):
                        right_operand = children[operand_idx]
                        if operator_rule == 'TOK_BINARY_SHIFT_LEFT':
                            result = BitwiseShiftLeftOp(left=result, right=right_operand, position=self._get_node_position(node))
                        elif operator_rule == 'TOK_BINARY_SHIFT_RIGHT':
                            result = BitwiseShiftRightOp(left=result, right=right_operand, position=self._get_node_position(node))
                        else:
                            # Default to shift left if unknown operator
                            result = BitwiseShiftLeftOp(left=result, right=right_operand, position=self._get_node_position(node))
                        operand_idx += 1
        except (TypeError, AttributeError, IndexError):
            # Fallback: if we can't access raw children, default to shift left
            result = children[0]
            for i in range(1, len(children)):
                result = BitwiseShiftLeftOp(left=result, right=children[i], position=self._get_node_position(node))
        
        return result
    
    def visit_prec_addition(self, node, children):
        # prec_addition rule: OneOrMore(prec_multiplication, sep=['+', '-'])
        # The children list contains: operands (Expression AST nodes) and operators (Terminal nodes with values '+', '-')
        # Operators are Terminal nodes passed through from _visit_node
        if len(children) == 1:
            return children[0]
        
        # Separate operands (Expression AST nodes) from operators (Terminal nodes with values '+', '-')
        operands = [child for child in children if isinstance(child, Expression)]
        operators = [child for child in children if not isinstance(child, Expression) and not isinstance(child, ASTNode)]
        
        if len(operands) == 1:
            return operands[0]
        
        if len(operands) != len(operators) + 1:
            # Fallback: if structure is unexpected, just chain operands with addition
            result = operands[0]
            for i in range(1, len(operands)):
                result = AdditionOp(left=result, right=operands[i], position=self._get_node_position(node))
            return result
        
        result = operands[0]
        for i in range(len(operators)):
            if i + 1 < len(operands):
                operator = operators[i] if isinstance(operators[i], str) else (getattr(operators[i], 'value', operators[i]) if hasattr(operators[i], 'value') else str(operators[i]))
                right_operand = operands[i + 1]
                if operator == '+':
                    result = AdditionOp(left=result, right=right_operand, position=self._get_node_position(node))
                elif operator == '-':
                    result = SubtractionOp(left=result, right=right_operand, position=self._get_node_position(node))
                else:
                    # Default to addition if unknown operator
                    result = AdditionOp(left=result, right=right_operand, position=self._get_node_position(node))
        
        return result
    
    def visit_prec_multiplication(self, node, children):
        # prec_multiplication rule: OneOrMore(prec_unary, sep=['*', '/', '%'])
        # The children list contains: operands (Expression AST nodes) and operators (Terminal nodes with values '*', '/', '%')
        # Operators are Terminal nodes passed through from _visit_node
        if len(children) == 1:
            return children[0]
        
        # Separate operands (Expression AST nodes) from operators (Terminal nodes with values '*', '/', '%')
        operands = [child for child in children if isinstance(child, Expression)]
        operators = [child for child in children if not isinstance(child, Expression) and not isinstance(child, ASTNode)]
        
        if len(operands) == 1:
            return operands[0]
        
        if len(operands) != len(operators) + 1:
            # Fallback: if structure is unexpected, just chain operands with multiplication
            result = operands[0]
            for i in range(1, len(operands)):
                result = MultiplicationOp(left=result, right=operands[i], position=self._get_node_position(node))
            return result
        
        result = operands[0]
        for i in range(len(operators)):
            if i + 1 < len(operands):
                operator = operators[i] if isinstance(operators[i], str) else (getattr(operators[i], 'value', operators[i]) if hasattr(operators[i], 'value') else str(operators[i]))
                right_operand = operands[i + 1]
                if operator == '*':
                    result = MultiplicationOp(left=result, right=right_operand, position=self._get_node_position(node))
                elif operator == '/':
                    result = DivisionOp(left=result, right=right_operand, position=self._get_node_position(node))
                elif operator == '%':
                    result = ModuloOp(left=result, right=right_operand, position=self._get_node_position(node))
                else:
                    # Default to multiplication if unknown operator
                    result = MultiplicationOp(left=result, right=right_operand, position=self._get_node_position(node))
        
        return result
    
    def visit_prec_unary(self, node, children):
        # prec_unary rule: (ZeroOrMore(['+', '-', TOK_LOGICAL_NOT, TOK_BINARY_NOT]), prec_exponent)
        # The node structure is: [operator1, operator2, ..., prec_exponent]
        # But Terminal nodes (operators) return None from _visit_node, so we need to access raw children
        exprs = [child for child in children if isinstance(child, Expression)]
        if not exprs:
            raise ValueError("prec_unary should have an Expression child")
        result = exprs[0]
        
        # Get raw node children to access operators
        try:
            node_children = list(node)
            # Operators are all Terminal nodes before the last child (which is prec_exponent)
            ops = []
            for i in range(len(node_children) - 1):  # All but the last child are operators
                operator_node = node_children[i]
                if hasattr(operator_node, 'value'):
                    op = operator_node.value
                elif hasattr(operator_node, 'rule_name'):
                    # Handle TOK_LOGICAL_NOT and TOK_BINARY_NOT
                    if operator_node.rule_name == 'TOK_LOGICAL_NOT':
                        op = '!'
                    elif operator_node.rule_name == 'TOK_BINARY_NOT':
                        op = '~'
                    else:
                        op = str(operator_node)
                else:
                    op = str(operator_node)
                ops.append(op)
            
            # Apply operators right-to-left (last operator first)
            for op in reversed(ops):
                if op == '-':
                    result = UnaryMinusOp(expr=result, position=self._get_node_position(node))
                elif op == '!':
                    result = LogicalNotOp(expr=result, position=self._get_node_position(node))
                elif op == '~':
                    result = BitwiseNotOp(expr=result, position=self._get_node_position(node))
                # '+' does nothing (unary plus)
        except (TypeError, AttributeError, IndexError):
            # Fallback: try to find operators in children (old behavior)
            ops = [child for child in children if isinstance(child, str) and child in ['+', '-', '!', '~']]
            for op in reversed(ops):
                if op == '-':
                    result = UnaryMinusOp(expr=result, position=self._get_node_position(node))
                elif op == '!':
                    result = LogicalNotOp(expr=result, position=self._get_node_position(node))
                elif op == '~':
                    result = BitwiseNotOp(expr=result, position=self._get_node_position(node))
        
        return result
    
    def visit_prec_exponent(self, node, children):
        # prec_exponent rule: [(prec_call, '^', prec_unary), prec_call]
        if len(children) == 1:
            return children[0]
        # Right-associative: a^b^c = a^(b^c)
        result = children[-1]
        for i in range(len(children) - 2, -1, -1):
            result = ExponentOp(left=children[i], right=result, position=self._get_node_position(node))
        return result
    
    def visit_prec_call(self, node, children):
        # prec_call rule: (primary, ZeroOrMore([call_expr, lookup_expr, member_expr]))
        if len(children) == 1:
            child = children[0]
            if isinstance(child, Expression):
                return child
            return child  # Fallback
        result = children[0]
        if not isinstance(result, Expression):
            # If first child is not an Expression, we can't proceed
            return result
        # Process suffixes left-to-right
        # The children after the first are tuples: ('call', args), ('index', expr), or ('member', identifier)
        for i in range(1, len(children)):
            child = children[i]
            if isinstance(child, tuple) and len(child) == 2:
                op_type, op_value = child
                if op_type == 'call':
                    arguments = op_value if isinstance(op_value, list) else [op_value] if isinstance(op_value, Argument) else []
                    result = PrimaryCall(left=result, arguments=arguments, position=self._get_node_position(node))
                elif op_type == 'index':
                    if isinstance(op_value, Expression):
                        result = PrimaryIndex(left=result, index=op_value, position=self._get_node_position(node))
                elif op_type == 'member':
                    if isinstance(op_value, Identifier):
                        result = PrimaryMember(left=result, member=op_value, position=self._get_node_position(node))
            elif isinstance(child, Expression):
                # Fallback: if it's already an Expression, use it directly
                result = child
        return result
    
    def visit_call_expr(self, node, children):
        # call_expr rule: ('(', arguments, ')')
        # children: list of Argument objects (from arguments rule)
        arguments = [child for child in children if isinstance(child, Argument)]
        # Return tuple marker for visit_prec_call
        return ('call', arguments)
    
    def visit_lookup_expr(self, node, children):
        # lookup_expr rule: ('[', expr, ']')
        expr = [child for child in children if isinstance(child, Expression)]
        if not expr:
            raise ValueError("lookup_expr should have an Expression child")
        # Return tuple marker for visit_prec_call
        return ('index', expr[0])
    
    def visit_member_expr(self, node, children):
        # member_expr rule: ('.', TOK_ID)
        # children: [Terminal ('.'), Identifier (from TOK_ID)]
        # Terminal nodes are now passed through, so we need to filter them out
        
        # Find the Identifier (should be the only AST node in children)
        identifier = None
        for child in children:
            if isinstance(child, Identifier):
                identifier = child
                break
        
        if identifier is None:
            # Fallback: try to extract name from children
            name_str = None
            for child in children:
                if isinstance(child, str) and child != '.':
                    name_str = child
                    break
                elif isinstance(child, Identifier):
                    name_str = child.name
                    break
            
            if name_str is None:
                raise ValueError("member_expr should have an Identifier child")
            identifier = Identifier(name=name_str, position=self._get_node_position(node))
        
        # Return tuple marker for visit_prec_call
        return ('member', identifier)
    
    def visit_primary(self, node, children):
        # primary rule handles multiple alternatives:
        # - ('(', expr, ')') -> just return the expr (already processed), filtering out '(' and ')'
        # - range_expr -> handled by visit_range_expr (returns RangeLiteral)
        # - vector_expr -> handled by visit_vector_expr (returns ListComprehension)
        # - TOK_UNDEF -> handled by visit_TOK_UNDEF (returns UndefinedLiteral)
        # - TOK_TRUE -> handled by visit_TOK_TRUE (returns BooleanLiteral)
        # - TOK_FALSE -> handled by visit_TOK_FALSE (returns BooleanLiteral)
        # - TOK_STRING -> handled by visit_TOK_STRING (returns StringLiteral)
        # - TOK_NUMBER -> handled by visit_TOK_NUMBER (returns NumberLiteral)
        # - TOK_ID -> handled by visit_TOK_ID (returns Identifier)
        # All children are already processed by their respective visitor methods
        # Filter out Terminal nodes (like '(' and ')') and return the first Expression/AST node
        if not children:
            raise ValueError("primary should have at least one child")
        
        # Filter out Terminal nodes (strings like '(', ')', '[', ']', etc.)
        ast_children = [child for child in children if isinstance(child, ASTNode)]
        if ast_children:
            return ast_children[0]
        
        # Fallback: return first child if no AST nodes found
        return children[0]
    
    def visit_range_expr(self, node, children):
        # range_expr rule: ('[', expr, ':', expr, Optional(':', expr), ']')
        # Children will be: expr, ':', expr, optional ':', optional expr
        # Extract expressions, filtering out ':' separators
        exprs = [child for child in children if isinstance(child, Expression)]
        if len(exprs) < 2:
            raise ValueError("range_expr should have at least 2 Expression children (start and end)")
        start = exprs[0]
        end = exprs[1]
        # Step is optional - if present, use it; otherwise default to 1.0
        step = exprs[2] if len(exprs) > 2 else NumberLiteral(val=1.0, position=self._get_node_position(node))
        return RangeLiteral(start=start, end=end, step=step, position=self._get_node_position(node))
    
    def visit_vector_expr(self, node, children):
        # vector_expr rule: ('[', vector_elements, Optional(TOK_COMMA), ']')
        # Children will be: vector_elements result (list), optional comma
        # visit_vector_elements returns a list of VectorElement or Expression
        elements = []
        for child in children:
            if isinstance(child, list):
                # vector_elements returns a list
                elements.extend([item for item in child if isinstance(item, (VectorElement, Expression))])
            elif isinstance(child, (VectorElement, Expression)):
                # Individual element (shouldn't happen, but handle it)
                elements.append(child)
        
        # ListComprehension expects list[VectorElement]
        # vector_element can be either listcomp_elements (VectorElement) or expr (Expression)
        # For simple vectors like [1, 2, 3], elements will be Expressions
        # For list comprehensions, elements will be VectorElements
        # We need to filter to only VectorElement types
        vector_elements_list = [elem for elem in elements if isinstance(elem, VectorElement)]
        
        # Note: If elements contains Expressions (simple vectors), they are filtered out.
        # This suggests that simple vectors might need a different AST representation,
        # or ListComprehension should accept both types. For now, we only include VectorElements.
        
        return ListComprehension(elements=vector_elements_list, position=self._get_node_position(node))
    
    def visit_funclit_def(self, node, children):
        # funclit_def rule: (TOK_FUNCTION, '(', parameters, ')', expr)
        # children: parameters list, expr
        params = [child for child in children if isinstance(child, ParameterDeclaration)]
        expr = [child for child in children if isinstance(child, Expression) and not isinstance(child, ParameterDeclaration)]
        if not expr:
            raise ValueError("funclit_def should have an Expression body")
        # FunctionLiteral needs arguments (list[Argument]), but we have parameters (list[ParameterDeclaration])
        # This seems like a mismatch in the AST definition - parameters should be used for function definition, not arguments
        # For now, create empty arguments list
        return FunctionLiteral(arguments=[], body=expr[0], position=self._get_node_position(node))
    
    def visit_vector_elements(self, node, children):
        # vector_elements rule: ZeroOrMore(vector_element, sep=TOK_COMMA)
        # Return list of VectorElement objects
        elements = [child for child in children if isinstance(child, (VectorElement, Expression))]
        return elements
    
    def visit_vector_element(self, node, children):
        # vector_element rule: [listcomp_elements, expr]
        # Return the first child (either a VectorElement from listcomp_elements, or an Expression)
        if not children:
            raise ValueError("vector_element should have at least one child")
        child = children[0]
        # If it's an Expression, wrap it appropriately
        # Actually, VectorElement is a base class, and Expression can be used directly in some contexts
        # For simplicity, return as-is
        return child
    
    def visit_listcomp_elements(self, node, children):
        # listcomp_elements rule: [('(', listcomp_elements, ')'), listcomp_let, listcomp_each, listcomp_for, listcomp_ifelse]
        # Return the first (and only) child
        if not children:
            raise ValueError("listcomp_elements should have at least one child")
        return children[0]
    
    def visit_listcomp_let(self, node, children):
        # listcomp_let rule: (TOK_LET, '(', assignments_expr, ')', listcomp_elements)
        assignments = [child for child in children if isinstance(child, Assignment)]
        # ListCompLet.body is Expression, but listcomp_elements returns VectorElement
        # Check the AST definition - it says body: Expression
        body = [child for child in children if isinstance(child, Expression) and not isinstance(child, Assignment)]
        if not body:
            # Try VectorElement as fallback (might need to check AST definition)
            vec_body = [child for child in children if isinstance(child, VectorElement) and not isinstance(child, Assignment)]
            if vec_body:
                # This is a type mismatch - ListCompLet expects Expression but we have VectorElement
                # For now, we'll need to check the actual AST definition
                raise ValueError(f"listcomp_let body type mismatch: ListCompLet expects Expression but got VectorElement")
            raise ValueError("listcomp_let should have a body")
        return ListCompLet(assignments=assignments, body=body[0], position=self._get_node_position(node))
    
    def visit_listcomp_each(self, node, children):
        # listcomp_each rule: (TOK_EACH, vector_element)
        body = [child for child in children if isinstance(child, VectorElement)]
        if not body:
            raise ValueError("listcomp_each should have a VectorElement body")
        return ListCompEach(body=body[0], position=self._get_node_position(node))
    
    def visit_listcomp_for(self, node, children):
        # listcomp_for rule: [(TOK_FOR, '(', assignments_expr, ';', expr, ';', assignments_expr, ')', vector_element), (TOK_FOR, '(', assignments_expr, ')', vector_element)]
        assignments = [child for child in children if isinstance(child, Assignment)]
        exprs = [child for child in children if isinstance(child, Expression) and not isinstance(child, Assignment)]
        body = [child for child in children if isinstance(child, VectorElement) and not isinstance(child, Assignment) and child not in exprs]
        if len(assignments) == 1 and len(exprs) == 0:
            # Simple for: for (assignments) body
            if not body:
                raise ValueError("listcomp_for should have a VectorElement body")
            return ListCompFor(assignments=assignments, body=body[0], position=self._get_node_position(node))
        elif len(assignments) == 2 and len(exprs) == 1:
            # C-style for: for (initial; condition; increment) body
            if not body:
                raise ValueError("listcomp_for should have a VectorElement body")
            return ListCompCStyleFor(initial=assignments[:1], condition=exprs[0], increment=assignments[1:], body=body[0], position=self._get_node_position(node))
        else:
            raise ValueError(f"listcomp_for has unexpected structure: {len(assignments)} assignments, {len(exprs)} expressions")
    
    def visit_listcomp_ifelse(self, node, children):
        # listcomp_ifelse rule: [(TOK_IF, '(', expr, ')', vector_element, TOK_ELSE, vector_element), (TOK_IF, '(', expr, ')', vector_element)]
        exprs = [child for child in children if isinstance(child, Expression)]
        vectors = [child for child in children if isinstance(child, VectorElement) and child not in exprs]
        if len(exprs) != 1:
            raise ValueError("listcomp_ifelse should have exactly one condition expression")
        condition = exprs[0]
        if len(vectors) == 2:
            return ListCompIfElse(condition=condition, true_expr=vectors[0], false_expr=vectors[1], position=self._get_node_position(node))
        elif len(vectors) == 1:
            return ListCompIf(condition=condition, true_expr=vectors[0], position=self._get_node_position(node))
        else:
            raise ValueError(f"listcomp_ifelse has unexpected structure: {len(vectors)} vector elements")
    
    def visit_modular_call(self, node, children):
        # modular_call rule: (TOK_ID, "(", arguments, ")", child_statement)
        # children: identifier, arguments list, module instantiations list
        name = children[0] if isinstance(children[0], Identifier) else Identifier(name=children[0], position=self._get_node_position(node))
        arguments = [child for child in children if isinstance(child, Argument)]
        mods = [child for child in children if isinstance(child, ModuleInstantiation)]
        return ModularCall(name=name, arguments=arguments, children=mods, position=self._get_node_position(node))
    
    def visit_modular_for(self, node, children):
        # modular_for rule: [(TOK_FOR, "(", assignments_expr, ")", child_statement), (TOK_FOR, "(", assignments_expr, ";", expr, ";", assignments_expr, ")", child_statement)]
        assignments = [child for child in children if isinstance(child, Assignment)]
        exprs = [child for child in children if isinstance(child, Expression) and not isinstance(child, Assignment)]
        mods = [child for child in children if isinstance(child, ModuleInstantiation)]
        if len(assignments) == 1 and len(exprs) == 0:
            # Simple for
            if not mods:
                raise ValueError("modular_for should have a ModuleInstantiation body")
            return ModularFor(assignments=assignments, body=mods[0], position=self._get_node_position(node))
        elif len(assignments) == 2 and len(exprs) == 1:
            # C-style for
            if not mods:
                raise ValueError("modular_for should have a ModuleInstantiation body")
            return ModularCLikeFor(initial=assignments[:1], condition=exprs[0], increment=assignments[1:], body=mods[0], position=self._get_node_position(node))
        else:
            raise ValueError(f"modular_for has unexpected structure")
    
    def visit_modular_intersection_for(self, node, children):
        # modular_intersection_for rule: (TOK_INTERSECTION_FOR, "(", assignments_expr, ")", child_statement)
        assignments = [child for child in children if isinstance(child, Assignment)]
        mods = [child for child in children if isinstance(child, ModuleInstantiation)]
        if not mods:
            raise ValueError("modular_intersection_for should have a ModuleInstantiation body")
        return ModularIntersectionFor(assignments=assignments, body=mods[0], position=self._get_node_position(node))
    
    def visit_modular_let(self, node, children):
        # modular_let rule: (TOK_LET, "(", assignments_expr, ")", child_statement)
        assignments = [child for child in children if isinstance(child, Assignment)]
        mods = [child for child in children if isinstance(child, ModuleInstantiation)]
        return ModularLet(assignments=assignments, children=mods, position=self._get_node_position(node))
    
    def visit_modular_echo(self, node, children):
        # modular_echo rule: (TOK_ECHO, "(", arguments, ")", child_statement)
        arguments = [child for child in children if isinstance(child, Argument)]
        mods = [child for child in children if isinstance(child, ModuleInstantiation)]
        return ModularEcho(arguments=arguments, children=mods, position=self._get_node_position(node))
    
    def visit_modular_assert(self, node, children):
        # modular_assert rule: (TOK_ASSERT, "(", arguments, ")", child_statement)
        arguments = [child for child in children if isinstance(child, Argument)]
        mods = [child for child in children if isinstance(child, ModuleInstantiation)]
        return ModularAssert(arguments=arguments, children=mods, position=self._get_node_position(node))
    
    def visit_ifelse_statement(self, node, children):
        # ifelse_statement rule: [(TOK_IF, '(', expr, ')', child_statement, TOK_ELSE, child_statement), (TOK_IF, '(', expr, ')', child_statement)]
        exprs = [child for child in children if isinstance(child, Expression)]
        mods = [child for child in children if isinstance(child, ModuleInstantiation)]
        if len(exprs) != 1:
            raise ValueError("ifelse_statement should have exactly one condition expression")
        condition = exprs[0]
        if len(mods) == 2:
            return ModularIfElse(condition=condition, true_branch=mods[0], false_branch=mods[1], position=self._get_node_position(node))
        elif len(mods) == 1:
            return ModularIf(condition=condition, true_branch=mods[0], position=self._get_node_position(node))
        else:
            raise ValueError(f"ifelse_statement has unexpected structure: {len(mods)} module instantiations")
    
    def visit_modifier_show_only(self, node, children):
        # modifier_show_only rule: ('!', module_instantiation)
        mods = [child for child in children if isinstance(child, ModuleInstantiation)]
        if not mods:
            raise ValueError("modifier_show_only should have a ModuleInstantiation child")
        return ModularModifierShowOnly(child=mods[0], position=self._get_node_position(node))
    
    def visit_modifier_highlight(self, node, children):
        # modifier_highlight rule: ('#', module_instantiation)
        mods = [child for child in children if isinstance(child, ModuleInstantiation)]
        if not mods:
            raise ValueError("modifier_highlight should have a ModuleInstantiation child")
        return ModularModifierHighlight(child=mods[0], position=self._get_node_position(node))
    
    def visit_modifier_background(self, node, children):
        # modifier_background rule: ('%', module_instantiation)
        mods = [child for child in children if isinstance(child, ModuleInstantiation)]
        if not mods:
            raise ValueError("modifier_background should have a ModuleInstantiation child")
        return ModularModifierBackground(child=mods[0], position=self._get_node_position(node))
    
    def visit_modifier_disable(self, node, children):
        # modifier_disable rule: ('*', module_instantiation)
        mods = [child for child in children if isinstance(child, ModuleInstantiation)]
        if not mods:
            raise ValueError("modifier_disable should have a ModuleInstantiation child")
        return ModularModifierDisable(child=mods[0], position=self._get_node_position(node))
    
    def visit_assignment(self, node, children):
        # assignment rule: (TOK_ID, TOK_ASSIGN, expr, ';')
        # Similar to assignment_expr but with semicolon
        name = children[0] if isinstance(children[0], Identifier) else Identifier(name=children[0], position=self._get_node_position(node))
        expr = [child for child in children[1:] if isinstance(child, Expression)]
        if not expr:
            raise ValueError("assignment should have an Expression child")
        return Assignment(name=name, expr=expr[0], position=self._get_node_position(node))
    
    def visit_comment_line(self, node, children):
        # comment_line rule: _(r'//.*?$', str_repr='comment')
        # The regex matches the entire comment including //, so node.value contains the full match
        # Follow the same pattern as other terminal nodes
        text = children[-1] if children else (node.value if hasattr(node, 'value') else "")
        # Remove the // prefix if present
        if text.startswith("//"):
            text = text[2:]
        return CommentLine(text=text, position=self._get_node_position(node))
    
    def visit_comment_multi(self, node, children):
        # comment_multi rule: _(r'(?ms)/\*.*?\*/', str_repr='comment')
        # The regex matches the entire comment including /* and */, so node.value contains the full match
        # Follow the same pattern as other terminal nodes
        text = children[-1] if children else (node.value if hasattr(node, 'value') else "")
        # Remove the /* prefix and */ suffix if present
        if text.startswith("/*"):
            text = text[2:]
        if text.endswith("*/"):
            text = text[:-2]
        return CommentSpan(text=text, position=self._get_node_position(node))
    
    def visit_comment(self, node, children):
        # comment rule: [comment_line, comment_multi]
        # This is a dispatcher - just return the first (and only) child
        if not children:
            raise ValueError("comment should have at least one child")
        return children[0]
    
    def visit_statement(self, node, children):
        # statement rule: [";", ('{', ZeroOrMore(statement), '}'), module_definition, function_definition, module_instantiation, assignment]
        # This is a dispatcher - children are already processed by their respective visitor methods
        # For semicolon (';'), there are no children, so we return None or skip
        # For block ('{', ZeroOrMore(statement), '}'), children contains: [None (from '{'), statement1, statement2, ..., None (from '}')]
        # For others, we get the appropriate AST node
        if not children:
            # Empty statement (semicolon)
            return None
        
        # Check if this is a block (starts and ends with None from '{' and '}')
        # Blocks have multiple children (statements inside)
        if len(children) > 1:
            # Filter out None values (from '{' and '}') and return the list of statements
            statements = [child for child in children if child is not None]
            # If we have multiple statements, return them as a list
            # Otherwise, return the single statement
            return statements if len(statements) > 1 else (statements[0] if statements else None)
        
        # Return the first child (module_definition, function_definition, module_instantiation, assignment)
        return children[0]
    
    def visit_module_instantiation(self, node, children):
        # module_instantiation rule: [modifier_show_only, modifier_highlight, modifier_background, modifier_disable, ifelse_statement, single_module_instantiation]
        # This is a dispatcher - children are already processed by their respective visitor methods
        if not children:
            raise ValueError("module_instantiation should have at least one child")
        # Return the first (and only) child, which is already the appropriate ModuleInstantiation AST node
        return children[0]
    
    def visit_single_module_instantiation(self, node, children):
        # single_module_instantiation rule: [modular_for, modular_intersection_for, modular_let, modular_assert, modular_echo, modular_call]
        # This is a dispatcher - children are already processed by their respective visitor methods
        if not children:
            raise ValueError("single_module_instantiation should have at least one child")
        # Return the first (and only) child, which is already the appropriate ModuleInstantiation AST node
        return children[0]
    
    def visit_child_statement(self, node, children):
        # child_statement rule: [';', ('{', ZeroOrMore([assignment, child_statement]), '}'), module_instantiation]
        # This is a dispatcher - children are already processed by their respective visitor methods
        # For semicolon (';'), there are no children, so we return None
        # For block ('{', ...), we might get a list of statements
        # For module_instantiation, we get the ModuleInstantiation AST node
        if not children:
            # Empty statement (semicolon)
            return None
        # Return the first child (module_instantiation or block)
        return children[0]
    
    def visit_expr(self, node, children) -> Expression:
        # expr rule: [let_expr, assert_expr, echo_expr, funclit_def, ternary_expr, prec_logical_or]
        # This is a dispatcher - children are already processed by their respective visitor methods
        if not children:
            raise ValueError("expr should have at least one child")
        # Return the first (and only) child, which is already the appropriate Expression AST node
        return children[0]
    
    def visit_openscad_language(self, node, children) -> list[ASTNode]:
        # openscad_language rule: (ZeroOrMore([use_statement, include_statement, statement]), EOF)
        # Collect all statements, filtering out EOF (Terminal nodes) and None values
        statements = [child for child in children if child is not None and isinstance(child, ASTNode)]
        return statements
    
    def visit_openscad_language_with_comments(self, node, children) -> list[ASTNode]:
        # openscad_language_with_comments rule: (ZeroOrMore([use_statement, include_statement, statement, comment]), EOF)
        # Collect all statements and comments, filtering out EOF (Terminal nodes) and None values
        statements = [child for child in children if child is not None and isinstance(child, ASTNode)]
        return statements

